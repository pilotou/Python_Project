### Q3: G function

A mathematical function `G` on positive integers is defined by two cases:

```
G(n) = n,                                       if n <= 3
G(n) = G(n - 1) + 2 * G(n - 2) + 3 * G(n - 3),  if n > 3
```

Write a recursive function `g` that computes `G(n)`. Then, write an iterative function `g_iter` that also computes `G(n)`:

```python
def g(n):
    """Return the value of G(n), computed recursively.

>>> g(1)
1
>>> g(2)
2
>>> g(3)
3
>>> g(4)
10
>>> g(5)
22
>>> from construct_check import check
>>> check(HW_SOURCE_FILE, 'g', ['While', 'For'])
True
"""
"*** YOUR CODE HERE ***"
	if n <= 3:
        return n
    else:
        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)
```

### Q4: Ping pong

The ping-pong sequence counts up starting from 1 and is always either counting up or counting down. At element `k`, the direction switches if `k` is a multiple of 7 or contains the digit 7. The first 30 elements of the ping-pong sequence are listed below, with direction swaps marked using brackets at the 7th, 14th, 17th, 21st, 27th, and 28th elements:

```
1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [-1] 0 1 2 3 4 [5] [4] 5 6
```

Implement a function `pingpong` that returns the nth element of the ping-pong sequence. *Do not use any assignment statements; however, you may use def statements*.

> *Hint*: If you're stuck, try implementing `pingpong` first using assignment and a `while` statement. Any name that changes value will become an argument to a function in the recursive definition.

```python
def pingpong(n):
    """Return the nth element of the ping-pong sequence.

>>> pingpong(7)
7
>>> pingpong(8)
6
>>> pingpong(15)
1
>>> pingpong(21)
-1
>>> pingpong(22)
0
>>> pingpong(30)
6
>>> pingpong(68)
2
>>> pingpong(69)
1
>>> pingpong(70)
0
>>> pingpong(71)
1
>>> pingpong(72)
0
>>> pingpong(100)
2
>>> from construct_check import check
>>> check(HW_SOURCE_FILE, 'pingpong', ['Assign', 'AugAssign'])
True
"""
"*** YOUR CODE HERE ***"
	def term(count, value, step):
        if count > n:
            return value
        elif count % 7 == 0 or has_seven(count):
            return term(count + 1, value + step, -step)
        else:
            return term(count + 1, value + step, step)

    return term(1, 0, 1)
```



### Q5: Count change

Once the machines take over, the denomination of every coin will be a power of two: 1-cent, 2-cent, 4-cent, 8-cent, 16-cent, etc. There will be no limit to how much a coin can be worth.

A set of coins makes change for `amount` if the sum of the values of the coins is `amount`. For example, the following sets make change for `7`:

- 7 1-cent coins
- 5 1-cent, 1 2-cent coins
- 3 1-cent, 2 2-cent coins
- 3 1-cent, 1 4-cent coins
- 1 1-cent, 3 2-cent coins
- 1 1-cent, 1 2-cent, 1 4-cent coins

Thus, there are 6 ways to make change for `7`. Write a function `count_change` that takes a positive integer `amount` and returns the number of ways to make change for `amount` using these coins of the future:

```python
def count_change(amount):
    """Return the number of ways to make change for amount.

>>> count_change(7)
6
>>> count_change(10)
14
>>> count_change(20)
60
>>> count_change(100)
9828
"""
"*** YOUR CODE HERE ***"
	p = 1
	while p < amount:
    	p *= 2
        
	def count(amount, worth):
        if amount == 0:
            return 1
        elif amount < 0 or worth == 0:
            return 0
        else:
            return count(amount - worth, worth) + count(amount, worth // 2)
  
	return count(amount, p // 2)

"*** YOUR CODE HERE ***(method 2)"
	def count_alt(amount, worth):
        if amount == 0:
            return 1
        elif amount < 0 or amount < worth:
            return 0
        else:
            return count_alt(amount - worth, worth) + count_alt(amount, worth * 2)

	return count_alt(amount, 1)
```

> Hint: you may find it helpful to refer to the [implementation](http://composingprograms.com/pages/17-recursive-functions.html#example-partitions) of `count_partitions`.

Use Ok to test your code:

```
python3 ok -q count_change
```

